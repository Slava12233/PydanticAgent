# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.


# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. 
- When integrating Logfire with httpx, you need to install the additional package `logfire[httpx]` to enable HTTP request monitoring.
- Always call `logfire.configure()` before using any other Logfire functions.
- Use `logfire.span()` for tracking longer operations and `logfire.info()`, `logfire.error()` for specific events.
- Remember to add proper cleanup with `logfire.force_flush()` and `logfire.shutdown()` to ensure all logs are sent.
- For multilingual documentation, include both Hebrew and English versions in the README.md file to make the project accessible to a wider audience.
- Maintain a modular architecture by separating concerns into different files (e.g., agent.py for AI logic, main.py for bot interface).
- When configuring timeouts in python-telegram-bot, use the defaults parameter in Application.builder() instead of trying to modify the _request.timeout attribute directly. The timeout is a tuple, not a single value.
- In python-telegram-bot v21.10, use a single 'timeout' key in the defaults dictionary instead of separate timeout types like 'connect_timeout', 'read_timeout', etc.
- In python-telegram-bot v21.10, use the Defaults class instead of a dictionary for the defaults parameter, and make sure to include tzinfo (e.g., datetime.timezone.utc).
- In python-telegram-bot v21.10, the Defaults class does not accept any timeout parameters. Timeouts must be configured elsewhere, not in the Defaults object.
- In python-telegram-bot v21.10, use the ApplicationBuilder methods (read_timeout, write_timeout, connect_timeout, pool_timeout) to set timeout values instead of trying to set them in the Defaults object.
- When migrating from SQLite to PostgreSQL, use SQLAlchemy as an ORM to make the transition smoother and maintain a consistent API.
- For PostgreSQL connections, install both `psycopg2-binary` and `sqlalchemy` packages.
- Use environment variables to store database connection details (host, port, database name, username, password) for better security and flexibility.
- When working with SQLAlchemy, define models that inherit from `declarative_base()` to create database tables.
- In SQLAlchemy, use `sessionmaker` to create database sessions for interacting with the database.
- Remember to call `db.init_db()` before using the database to ensure tables are created and the connection is established.
- When accessing an object's attributes after a database session is closed, you'll get a DetachedInstanceError. Save any needed values before closing the session.
- After migrating from SQLite to PostgreSQL, make sure to remove all references to the old database file and code to avoid confusion.
- When implementing a RAG system, create a separate module for document management to keep the code organized.
- For RAG systems, use a database model that can store document chunks with metadata for efficient retrieval.
- Implement a command-line interface for document management to allow for easy testing and administration.
- When adding documents to a RAG system, split them into smaller chunks for more precise retrieval.
- Include proper error handling in document management functions to prevent crashes when dealing with file operations.
- Make sure to update the README.md with detailed instructions on how to use the RAG system, both via the bot and command line.
- When using SQLAlchemy, always use text() for raw SQL queries to avoid the "Textual SQL expression should be explicitly declared as text()" error.
- When using pgvector in PostgreSQL, make sure the extension is installed in the database. If not, use ARRAY(Float) as a temporary alternative for storing embeddings.
- When testing database functionality, verify that the tables exist and have the correct structure before running more complex tests. This helps identify schema issues early.
- For Telegram user IDs, use BigInteger instead of Integer in SQLAlchemy models, as Telegram IDs can be very large numbers that exceed the range of a standard 32-bit integer.
- When implementing search functionality in a RAG system, set a min_similarity parameter (e.g., 0.0) to ensure results are returned even when the similarity score is low.
- Provide clear and detailed feedback to users when they interact with document management features, including emojis and formatting for better readability.
- Validate user input for document titles and content to prevent issues with empty or oversized files.
- Include comprehensive error handling for file operations, especially when dealing with different encodings and file formats.
- When displaying search results, convert similarity scores to percentages for better user understanding (e.g., 0.75 → 75%).
- Use Markdown formatting in Telegram messages to improve readability and highlight important information.
- When importing the datetime module, make sure to import the specific classes you need (e.g., `from datetime import datetime, timezone`) rather than importing the entire module (e.g., `import datetime`). This avoids errors like `datetime.utcnow()` vs `datetime.datetime.utcnow()`.
- When using timezone information with datetime, remember to import the timezone class explicitly: `from datetime import timezone`.
- When implementing error handling in AI agents, categorize errors by type (quota, timeout, content filter) for more specific user feedback.
- For quota errors with OpenAI API, implement a fallback mechanism to switch to alternative models automatically.
- When working with multiple model providers (OpenAI, Anthropic), use a prefix convention (e.g., 'openai:', 'anthropic:') to clearly identify the provider.
- Add user commands to switch between models (/switch_model) and set fallback models (/set_fallback) for better user control.
- Implement a /help command that lists all available commands with descriptions for better user experience.
- Add a /models command to show users which models are currently active (primary and fallback).
- When handling API errors, provide specific, helpful messages that guide users on what actions they can take.
- For timeout errors, suggest that users break down complex questions into smaller parts.
- For content filter errors, explain that the question violates content policies and suggest rephrasing.
- Use try-except blocks with specific exception types rather than catching all exceptions generically when possible.
- Log different error types with appropriate severity levels (warning for quota issues, error for other failures).
- When writing asynchronous tests in Python, create a base AsyncTestCase class that includes a run_async method to properly execute and await coroutines. This prevents "coroutine was never awaited" warnings and ensures proper test execution.
- For testing asynchronous functions, wrap the test logic in a nested async function and use asyncio.run() to execute it, rather than making the test method itself async.
- When mocking asynchronous functions, use AsyncMock instead of regular MagicMock to properly simulate async behavior.
- When testing WooCommerce API integration, use environment variables (TEST_STORE_URL, TEST_CONSUMER_KEY, TEST_CONSUMER_SECRET) to store test store credentials.
- For WooCommerce product testing, use the "draft" status to prevent test products from appearing in the live store.
- Always clean up test products after testing by deleting them from the store to avoid cluttering the database.
- When testing product creation, use a timestamp in the product name to ensure uniqueness and make it easy to identify test products.
- For performance testing, measure execution time in milliseconds and set reasonable thresholds (e.g., less than 1000ms) for each operation.
- When testing Hebrew support, check both text processing (input) and display formatting (output) to ensure full compatibility.
- Test Markdown parsing specifically with Hebrew text to catch any RTL (right-to-left) formatting issues.
- Remember that we're building an MVP (Minimum Viable Product), so focus on core functionality that works well rather than implementing every possible feature.
- All store operations must work through natural conversation, not just through commands. The main agent should guide users who don't know how to use commands.
- The agent should proactively help users navigate the system, not expect users to know all the commands or exact syntax.
- When implementing task type identification, include a wide range of natural language expressions and variations to handle different ways users might phrase their requests.
- For task type identification, include both formal and informal language patterns, as users often use casual language in chat interfaces.
- When adding keywords for task identification, consider adding complete phrases and not just individual words to improve accuracy.
- For better task identification, assign higher scores to longer, more specific phrases that match user queries.
- When testing task identification, create a comprehensive test suite with various phrasings to ensure the system handles different ways of expressing the same intent.
- When dealing with Hebrew text in console output, use proper encoding settings (UTF-8) to avoid character display issues.
- For testing functionality with Hebrew text, consider writing results to files instead of relying solely on console output, which may have encoding limitations.
- When implementing product creation from natural language, ensure the extraction of product data is robust and can handle various ways users might describe products.
- For WooCommerce integration, use a caching mechanism to improve performance and reduce API calls, especially for read operations.
- When implementing caching for WooCommerce API, make sure to invalidate the cache after write operations (POST, PUT, DELETE) to ensure data consistency.
- For product management, provide clear feedback to users about the status of their operations, including success messages and error details when applicable.
- כאשר עובדים עם תאריכים בפייתון ומבצעים מניפולציות על חודשים, יש לטפל בכל המקרים האפשריים (במיוחד כאשר החודש הוא 1 או 12) כדי למנוע שגיאות כמו `ValueError: month must be in 1..12`. למשל, כאשר מחשבים תאריך לפני שנה, יש לטפל בנפרד במקרה שהחודש הוא 12 (יש לחזור לחודש 1 של השנה הקודמת) ובמקרה שהחודש הוא בין 1 ל-11 (יש לחזור לחודש הבא של השנה הקודמת).

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- The project uses Pydantic AI as the main framework for AI integration, which provides a clean interface for working with LLMs
- The Telegram bot is implemented using python-telegram-bot library and supports Hebrew language
- PostgreSQL is used for storing chat history with SQLAlchemy as the ORM
- Logfire provides comprehensive monitoring for AI applications, tracking HTTP requests, database operations, and model interactions
- When working with Telegram bots, increase timeout values to prevent "Timed out" errors during API calls
- Use a modular architecture with separate files for bot logic, agent implementation, and main application flow
- For RAG systems, create a dedicated tools directory to house utility functions like document management
- When implementing a RAG system, update the configuration file to include new commands for document operations
- Store document chunks in the database with metadata to enable efficient retrieval during conversations
- Implement both bot commands and command-line interfaces for document management to provide flexibility
- For WooCommerce integration, use a caching mechanism to improve performance and reduce API calls
- When implementing caching, ensure cache invalidation occurs when data is modified (POST, PUT, DELETE requests)
- Test caching performance by comparing execution times with and without caching enabled
- When testing functionality with Hebrew text in Windows PowerShell, be aware of potential encoding issues that may cause display problems
- The product management system includes robust extraction of product data from natural language text
- The system uses a comprehensive approach to format product displays with emojis and clear structure for better user experience

# Scratchpad

# Scratchpad

## תוכנית רה-ארגון ושיפור הארכיטקטורה  2025

### שלב 1: ארגון מחדש של מבנה הקבצים
[ ] יצירת ענף git חדש לרה-ארגון הארכיטקטורה
[ ] איחוד תיקיות core ו-agents/core לתיקייה אחת מאורגנת
[ ] העברת כל המודלים לתיקיית models מרכזית
[ ] יצירת תיקיית ui לכל ממשקי המשתמש (טלגרם וכו')
[ ] ארגון מחדש של תיקיית services לפי תחומי אחריות
[ ] ארגון מחדש של תיקיית tools לפי תחומי אחריות

### שלב 2: טיפול בכפילויות קוד
[ ] איחוד מודל ChatResponse למודל אחד בתיקיית models
[ ] איחוד פונקציונליות task_identifier לקובץ אחד מקיף
[ ] איחוד מערכת הפרומפטים תחת מנגנון אחד מבוסס YAML
[ ] הסרת כפילויות בקוד זיהוי כוונות בין tools/intent ו-agents/core
[ ] איחוד לוגיקת ניהול הקשר בין context_manager ו-memory_service

### שלב 3: פיצול קבצים ארוכים
[ ] פיצול rag_service.py (615 שורות):
  [ ] rag_core.py - המחלקה הראשית והפונקציות הבסיסיות
  [ ] rag_search.py - פונקציות חיפוש
  [ ] rag_document.py - פונקציות ניהול מסמכים
  [ ] rag_utils.py - פונקציות עזר

[ ] פיצול telegram_bot.py (2633 שורות):
  [ ] telegram_core.py - המחלקה הראשית ופונקציות בסיסיות
  [ ] telegram_commands.py - טיפול בפקודות
  [ ] telegram_conversations.py - טיפול בשיחות
  [ ] telegram_callbacks.py - טיפול בקריאות callback
  [ ] telegram_media.py - טיפול במדיה
  [ ] telegram_products.py - טיפול במוצרים
  [ ] telegram_orders.py - טיפול בהזמנות

[ ] פיצול prompts.py (341 שורות):
  [ ] prompt_manager.py - ניהול פרומפטים
  [ ] prompt_templates.py - תבניות פרומפטים
  [ ] prompt_utils.py - פונקציות עזר

[ ] פיצול constants.py (172 שורות):
  [ ] product_keywords.py - מילות מפתח למוצרים
  [ ] order_keywords.py - מילות מפתח להזמנות
  [ ] customer_keywords.py - מילות מפתח ללקוחות
  [ ] general_constants.py - קבועים כלליים

### שלב 4: הפרדת אחריות ברורה
[ ] הפרדת לוגיקת ממשק משתמש מלוגיקה עסקית:
  [ ] העברת לוגיקת UI לתיקיית ui
  [ ] העברת לוגיקה עסקית לתיקיית services

[ ] הגדרת ממשקים ברורים בין המודולים:
  [ ] יצירת ממשקים (interfaces) לכל שירות
  [ ] הגדרת חוזים ברורים בין המודולים

[ ] הקטנת תלויות בין מודולים:
  [ ] שימוש בהזרקת תלויות (dependency injection)
  [ ] שימוש בתבנית Factory ליצירת אובייקטים

### שלב 5: שיפור מערכת הפרומפטים
[ ] יצירת מערכת פרומפטים אחידה:
  [ ] העברת כל הפרומפטים לקבצי YAML
  [ ] יצירת מנגנון טעינה דינמי של פרומפטים
  [ ] הוספת תמיכה בשפות נוספות

[ ] שיפור מנגנון בניית פרומפטים:
  [ ] יצירת מנגנון תבניות גמיש
  [ ] הוספת תמיכה בפרמטרים דינמיים
  [ ] הוספת מנגנון קאשינג לפרומפטים

### שלב 6: שיפור מערכת הבדיקות
[ ] יצירת בדיקות יחידה לכל מודול:
  [ ] בדיקות למודולי הליבה
  [ ] בדיקות לשירותים
  [ ] בדיקות לממשקי משתמש

[ ] יצירת בדיקות אינטגרציה:
  [ ] בדיקות לתהליכים מקצה לקצה
  [ ] בדיקות לתרחישי משתמש מורכבים

[ ] הוספת CI/CD:
  [ ] הגדרת GitHub Actions לבדיקות אוטומטיות
  [ ] הוספת בדיקות כיסוי קוד

### שלב 7: שיפור התיעוד
[ ] הוספת docstrings לכל הפונקציות והמחלקות
[ ] יצירת תיעוד API פנימי
[ ] עדכון README.md עם מידע על הארכיטקטורה החדשה
[ ] הוספת דיאגרמות ארכיטקטורה

### שלב 8: אופטימיזציה וביצועים
[ ] מדידת ביצועים של המודולים השונים
[ ] זיהוי צווארי בקבוק וטיפול בהם
[ ] הוספת מנגנוני קאשינג נוספים
[ ] אופטימיזציה של שאילתות מסד הנתונים

## מדדי הצלחה לרה-ארגון

1. **הפחתת גודל קבצים**: אף קובץ לא יעלה על 300 שורות קוד
2. **הפחתת תלויות**: כל מודול יהיה תלוי במספר מינימלי של מודולים אחרים
3. **כיסוי בדיקות**: לפחות 80% כיסוי קוד בבדיקות יחידה
4. **זמני טעינה**: הפחתת זמן טעינת המערכת ב-30%
5. **קלות הרחבה**: הוספת פיצ'ר חדש תדרוש שינויים במספר מינימלי של קבצים
6. **תיעוד**: כל פונקציה ומחלקה תהיה מתועדת היטב
7. **ביצועים**: שמירה או שיפור זמני התגובה למשתמש


